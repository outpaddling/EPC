<?xml version="1.0" encoding="UTF-8"?>

<book xml:id="EPC" xmlns="http://docbook.org/ns/docbook" version="5.0">
    <title>Educational Personal Computer</title>
    
    <chapter xml:id="goals">
	<title>Goals</title>
	
	<section>
	    <title>Audience</title>
	    
	    <para>
	    EPC is a training tool for computer programmers and
	    engineers.
	    </para>
	    
	    <para>
	    It is meant for use in classes teaching assembly language,
	    computer architecture, compiler design, and similar topics.
	    </para>
	</section>
	
	<section>
	    <title>Why a Simulator?</title>
	    
	    <para>
	    Simulators have major advantages over real hardware as
	    educational tools.
	    </para>
	    
	    <itemizedlist>
		<listitem>
		Simulators allow the user to easily monitor the inner workings
		of a computer in as much detail as desired.
		</listitem>
		
		<listitem>
		Hardware costs money.  It must be purchased, maintained,
		upgraded and replaced.
		</listitem>
		
		<listitem>
		A simulator, like any properly-written software, can be
		made portable, so that it can be used on virtually any
		operating system and hardware.
		</listitem>
	    </itemizedlist>
	</section>
	
	<section>
	    <title>Why EPC?</title>
	    
	    <itemizedlist>
		<listitem>
		The EPC architecture is much easier to learn and use
		than most modern commercial architectures.  The instruction
		set and machine code format are simple, but complete.
		Students will not be overwhelmed with complexity and
		will be exposed to all major computer architecture concepts
		such as memory hierarchy, addressing modes, etc.
		</listitem>
		
		<listitem>
		Free and open source.
		</listitem>
		
		<listitem>
		The EPC simulator is written in ANSI C and the assembler
		is written in ANSI C++.  Both are designed to be portable to
		any POSIX-compatible platform.  This includes any Unix-like
		system, including Mac OS X, and MS Windows running Cygwin
		or any other POSIX compatibility system.
		</listitem>
		
		<listitem>
		EPC more accurately simulates the programming process of
		real hardware.  Programs are written in any text editor,
		then assembled to produce a machine-code "binary", which is
		executed by the simulator.
		</listitem>
		
		<listitem>
		The machine code binaries are in the form of a human-readable
		"list" file, showing the machine code and assembly
		code side-by-side.
		</listitem>
		
		<listitem>
		EPC reports a great deal of information about programs, such
		as the number of instructions executed, the number of clock
		cycles used, unaligned memory accesses, memory used, etc.
		This allows
		programs to be easily rated for objective quality measures
		such as speed and resource use.
		</listitem>
	    </itemizedlist>
	    
	</section>
    </chapter>
    
    <chapter xml:id="architecture">
	<title>The EPC Architecture</title>
	
	<section>
	    <title>Consistency</title>
	    
	    <para>
	    EPC machine code is 100% consistent.
	    </para>
	    
	    <para>
	    Unlike some simulators, the EPC architecture is little-endian
	    regardless of the underlying architecture.  This means a
	    small performance penalty when running on a big-endian
	    computer, but the difference is not noticeable.
	    </para>
	</section>
	
	<section>
	    <title>Data Types</title>
	    
	    <table xml:id="data-type-table" frame='all'>
		<title>Data Types</title>
		<tgroup cols='3' align='left' colsep='1' rowsep='1'>
		    <thead>
		    <row>
			<entry>Type</entry>
			<entry>Suffix used in instructions</entry>
			<entry>Description</entry>
		    </row>
		    </thead>
		    
		    <tbody>
		    <row>
			<entry>byte</entry>
			<entry>b</entry>
			<entry>8-bit integer or raw bit data</entry>
		    </row>
		    <row>
			<entry>short</entry>
			<entry>s</entry>
			<entry>16-bit integer or raw bit data</entry>
		    </row>
		    <row>
			<entry>long</entry>
			<entry>l</entry>
			<entry>32-bit integer or raw bit data</entry>
		    </row>
		    <row>
			<entry>quad</entry>
			<entry>q</entry>
			<entry>64-bit integer or raw bit data</entry>
		    </row>
		    <row>
			<entry>float</entry>
			<entry>f</entry>
			<entry>32-bit IEEE floating point</entry>
		    </row>
		    <row>
			<entry>double</entry>
			<entry>d</entry>
			<entry>64-bit IEEE floating point</entry>
		    </row>
		    <row>
			<entry>address</entry>
			<entry>a</entry>
			<entry>32?-bit memory address</entry>
		    </row>
		    </tbody>
		</tgroup>
	    </table>
	</section>
	
	<section>
	    <title>Instruction Set</title>
	</section>
	
	<section>
	    <title>Addressing Modes</title>
	</section>
	
	<section>
	    <title>Registers</title>
	</section>
	
	<section>
	    <title>Busses</title>
	</section>
	
	<section>
	    <title>Memory Map</title>
	</section>
	
	<section>
	    <title>I/O Addresses</title>
	</section>
	
	<section>
	    <title>Exceptions</title>
	</section>
	
	<section>
	    <title>DMA</title>
	</section>
	
	<section>
	    <title>Disk</title>
	</section>
	
	<section>
	    <title>Display</title>
	</section>
	
	<section>
	    <title>Cache</title>
	</section>
	
	<section>
	    <title>Virtual Memory</title>
	</section>
	
	<section>
	    <title>Device Plugins</title>
	</section>
    </chapter>
</book>

